<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Race Condition</title>
    <subtitle>A Blog by Josh Adams</subtitle>
    <link href="http://racecondition.software/feed.xml" rel="self" />
    <link href="http://racecondition.software" />
    <updated>2018-04-15T19:03:07-07:00</updated>
    <id>http://racecondition.software</id>

    <author>
        <name>Josh Adams</name>
    </author>

    <icon>http://racecondition.software/ico/logo.jpg</icon>

    <category term="programming"/>
    <category term="ios"/>
    <category term="swift"/>
    <category term="objective-c"/>
    <category term="software"/>
    <category term="mobile"/>

    
    <entry>
        <link href="http://racecondition.software/blog/programmatic-layout/" />
        <id>http://racecondition.software/blog/programmatic-layout</id>
        <title>Converting an App from Interface Builder to Programmatic Layout</title>
        <subtitle>A Step-by-Step Tutorial</subtitle>
        <published>2018-04-08T00:00:00-07:00</published>
        
        <updated>2018-04-08T00:00:00-07:00</updated>
        
        <summary><p>This tutorial teaches programmatic layout (PL) by demonstrating conversion of an app‚Äôs user interface (UI) from <a href="https://youtu.be/dl0CbKYUFTY">Interface Builder</a> (IB) to PL.</p>


        </summary>
        <content type="html">&lt;p&gt;This tutorial teaches programmatic layout (PL) by demonstrating conversion of an app‚Äôs user interface (UI) from &lt;a href=&quot;https://youtu.be/dl0CbKYUFTY&quot;&gt;Interface Builder&lt;/a&gt; (IB) to PL.&lt;/p&gt;

&lt;!--excerpt--&gt;

&lt;h3 id=&quot;definitions&quot;&gt;Definitions&lt;/h3&gt;

&lt;p&gt;IB is &lt;a href=&quot;https://en.wikipedia.org/wiki/Interface_Builder&quot;&gt;descended&lt;/a&gt; from a visual UI editor originally created for the NeXTSTEP operating system. As of Xcode 4, IB is integrated into Xcode itself. Using the IB approach, developers drag UI elements from the Object library onto a storyboard or XIB and then set most or all Auto Layout constraints and UI-element properties using the IB UI. A storyboard is an XML-backed representation of the UI elements of, and connections among, one or more view controllers and their views. A XIB is an XML-backed representation of the UI elements of one view. The Objective-C runtime instantiates views and view controllers represented by XIBs and storyboards.&lt;/p&gt;

&lt;p&gt;The PL approach eschews IB. Using PL, developers instantiate UI elements, set their properties, and set Auto Layout constraints using Objective-C or Swift.&lt;/p&gt;

&lt;p&gt;In practice, developers often use IB and PL in tandem.  Production-quality apps are likely to have some UI properties and/or constraints that must be set in code, for example if the app has themes or animations. Ardent PL developers cannot entirely avoid IB because editing launch screens requires use of IB.&lt;/p&gt;

&lt;h3 id=&quot;plusses-and-minuses-of-ib-vis-√†-vis-pl&quot;&gt;Plusses and Minuses of IB &lt;em&gt;Vis √† Vis&lt;/em&gt; PL&lt;/h3&gt;

&lt;p&gt;Proponents of IB cite, &lt;em&gt;inter alia&lt;/em&gt;, the following advantages:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IB is more approachable for iOS-development learners, perhaps explaining why many iOS-development-learning &lt;a href=&quot;http://web.stanford.edu/class/cs193p/cgi-bin/drupal/&quot;&gt;resources&lt;/a&gt; teach &lt;a href=&quot;https://store.raywenderlich.com/products/swift-apprentice&quot;&gt;the&lt;/a&gt; IB approach. Fortunately for the PL-learner, Brian Voong does teach PL in &lt;a href=&quot;https://www.youtube.com/watch?v=bd2KSWLXo3A&quot;&gt;his&lt;/a&gt; YouTube &lt;a href=&quot;https://www.youtube.com/watch?v=9RydRg0ZKaI&quot;&gt;videos&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Apple is promoting use of IB in WWDC sessions, suggesting that IB is more future-proof than PL. Future iOS features might not be available to PL developers in the same way that multitasking on iPad is not available to developers who have not adapted size classes. By way of analogy, developers who did not adopt size classes did not get iPad multi-tasking.&lt;/li&gt;
  &lt;li&gt;Creating a UI in IB is faster and easier to iterate on. In concrete terms, dragging UI elements around a storyboard and fiddling with their properties until the UI takes useful shape is easy, but creating a UI in code without knowing ahead of time &lt;em&gt;exactly&lt;/em&gt; what form the UI should take is nigh-impossible. In practice, therefore, PL requires use of some other design tool, for example Sketch or a &lt;a href=&quot;http://aged-and-distilled.com&quot;&gt;n&lt;/a&gt;apkin.&lt;/li&gt;
  &lt;li&gt;An app that uses IB has fewer lines of Swift or Objective-C code than an identically functioning app that uses PL. &lt;a href=&quot;https://blog.codinghorror.com/the-best-code-is-no-code-at-all/&quot;&gt;Less code is better.&lt;/a&gt; There is an argument that the nuts and bolts of UI creation and layout are not central to an app‚Äôs functionality, so developers should offload those nuts and bolts, to the extent possible, to IB in the same way that developers sometimes offload creation and maintenance of their object graphs to CoreData.&lt;/li&gt;
  &lt;li&gt;Relatedly, because most iOS-UI sample code demonstrates use of IB, not PL, initial use of PL sometimes requires more research. For example, when the &lt;a href=&quot;https://twitter.com/vermont42&quot;&gt;author&lt;/a&gt; of this tutorial (the Author) was adding a scroll view to his PL-based app, &lt;a href=&quot;https://github.com/vermont42/Conjugar&quot;&gt;Conjugar&lt;/a&gt;, he had a üêª of a time setting up the constraints and ownership graph so that the scroll view functioned properly because, in part, of the dearth of PL sample code on the Internet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Proponents of PL cite, &lt;em&gt;inter alia&lt;/em&gt;, the following disadvantages of IB:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Using IB results in less Objective-C or Swift code, but IB does use ‚Äúcode‚Äù in the form of an undocumented, arguably inscrutable XML file. In one production iOS &lt;a href=&quot;https://github.com/vermont42/RaceRunner&quot;&gt;app&lt;/a&gt;, this &lt;a href=&quot;https://github.com/vermont42/RaceRunner/blob/master/RaceRunner/Main.storyboard&quot;&gt;file&lt;/a&gt; is 2503 lines long.&lt;/li&gt;
  &lt;li&gt;IB‚Äôs XML format is subject to change between Xcode versions. Changes in format can cause warnings that the developer has to fix. &lt;a href=&quot;https://itunes.apple.com/us/app/immigration/id777319358&quot;&gt;Two&lt;/a&gt; &lt;a href=&quot;https://itunes.apple.com/us/app/racerunner-run-tracking-app/id1065017082&quot;&gt;apps&lt;/a&gt; developed by the Author experienced these warnings, examples of which appear in the following screenshot.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/warnings.jpg&quot; title=&quot;Warnings&quot; alt=&quot;Warnings&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;Warnings from Interface Builder After Xcode Upgrade &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;Because the IB file format is not backwards-compatible, old storyboards and XIBs cannot even be opened in newer versions of Xcode, a situation described &lt;a href=&quot;http://www.lapcatsoftware.com/articles/working-without-a-nib-part-11.html&quot;&gt;here&lt;/a&gt;. UIs created in IB are, in that sense, ticking time-bombs. As Swift evolves, old PL code may not compile, but it can always be opened in Xcode and grokked by the developer.&lt;/li&gt;
  &lt;li&gt;IB hides implementation details from the iOS-development-learner. For example, an IB learner learning about tab bars might learn to click a view controller in the storyboard and click Editor -&amp;gt; Embed In -&amp;gt; Tab Bar Controller. The learner might not realize that a &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarController&lt;/code&gt; gets instantiated at runtime. A PL learner learning about tab bars can‚Äôt avoid instantiating &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarController&lt;/code&gt; explicitly. The PL approach therefore fosters deeper understanding of &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;By requiring the developer to set, by hand, the value of every color, font, padding, and constraint, the IB approach
violates the &lt;a href=&quot;http://deviq.com/don-t-repeat-yourself/&quot;&gt;DRY&lt;/a&gt; principle. Global changes to colors, fonts, paddings, and constraint constants are tedious and error-prone. With the PL approach, these values are set once in code and are easy to change globally.&lt;/li&gt;
  &lt;li&gt;As in &lt;a href=&quot;https://www.sciencedaily.com/releases/1998/02/980227055013.htm&quot;&gt;quantum theory&lt;/a&gt;, the act of observing a storyboard or XIB affects its reality. That is to say, opening a storyboard or XIB in IB ‚Äúdirties‚Äù the underlying file, a change picked up by source control unless discarded. In a world where reviewers of pull requests rightfully expect every commit in a pull request to reflect developer intent, these no-op changes are problematic.&lt;/li&gt;
  &lt;li&gt;Finally, the inscrutable nature of XIB and storyboard files makes resolving merge conflicts in a team environment challenging. Admittedly, these conflicts can be minimized, but not eliminated, by putting each &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;‚Äôs visual representation in its own storyboard.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tutorial&quot;&gt;Tutorial&lt;/h3&gt;

&lt;p&gt;This tutorial takes no position as to whether PL or IB is the better approach. But because of PL‚Äôs many benefits, this tutorial &lt;em&gt;does&lt;/em&gt; argue that developers who know only IB would benefit from learning PL. A desire to facilitate this learning prompted this tutorial, which begins after the following disclaimer: The tutorial assumes working knowledge of iOS development with IB and, in particular, Auto Layout. Readers not in possession of that knowledge might find helpful &lt;a href=&quot;https://www.youtube.com/watch?v=71pyOB4TPRE&quot;&gt;CS193P&lt;/a&gt;, which was the Author‚Äôs entr√©e to iOS development.&lt;/p&gt;

&lt;p&gt;1. Clone, build, and run the &lt;a href=&quot;https://github.com/vermont42/CatBreedsIB&quot;&gt;starter project&lt;/a&gt;. Explore cat breeds.&lt;/p&gt;

&lt;p&gt;2. Poke around the code and storyboard. The app is intended to be simple enough to grok without much effort but complicated enough to demonstrate various PL techniques. Here are some comments on the implementation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There is no way to edit attributed strings in IB, so for the credits screen, the app uses a sort of Markdown-lite that allows different formatting for headings and subheadings. See &lt;code class=&quot;highlighter-rouge&quot;&gt;StringExtensions.swift&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Credits.swift&lt;/code&gt; for implementation and use, respectively. This technique, developed for &lt;a href=&quot;https://itunes.apple.com/us/app/racerunner-run-tracking-app/id1065017082&quot;&gt;RaceRunner&lt;/a&gt; and used by &lt;a href=&quot;https://itunes.apple.com/us/app/conjugar/id1236500467&quot;&gt;Conjugar&lt;/a&gt;, works well in this and other simple use cases despite not providing the full power of Markdown.&lt;/li&gt;
  &lt;li&gt;There is, &lt;a href=&quot;https://dictionary.law.com/Default.aspx?selected=954&quot;&gt;on information and belief&lt;/a&gt;, no way to set tab- or navigation-bar fonts in IB, so the app uses an app-delegate-initiated approach.&lt;/li&gt;
  &lt;li&gt;App-and-button icons are from &lt;a href=&quot;https://thenounproject.com&quot;&gt;The Noun Project&lt;/a&gt;. Consider using this website if you need professional-grade icons but do not have the skill to make them or the budget to commission them.&lt;/li&gt;
  &lt;li&gt;The app‚Äôs color palette is from &lt;a href=&quot;https://coolors.co&quot;&gt;Coolors&lt;/a&gt;. The Author is not an artist, so he uses this website for suggestions of harmonious color palettes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3. You might think that the first step of converting an app from IB to PL is to delete the storyboard, but that is not the case because the storyboard can serve as a reference as you implement &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s in code. So don‚Äôt delete the storyboard. But you do need to tell the runtime not to use the storyboard to create the UI. So in the file &lt;code class=&quot;highlighter-rouge&quot;&gt;Info.plist&lt;/code&gt;, find the key &lt;code class=&quot;highlighter-rouge&quot;&gt;Main storyboard file base name&lt;/code&gt;, click it, and press the &lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt; key.&lt;/p&gt;

&lt;p&gt;As an aside, when this tutorial refers to a file in the project, the easiest way to find the file is to click the Project Navigator button in the top-left corner of Xcode and type the filename in the search bar, as shown in this screenshot.&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/files.png&quot; title=&quot;Files&quot; alt=&quot;Files&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;Finding a File in Project Navigator &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;4. Resist temptation. Do not build &lt;em&gt;or&lt;/em&gt; run. The runtime no longer knows what UI to show, so running would be pointless. You must &lt;em&gt;tell&lt;/em&gt; the runtime what UI to show. In &lt;code class=&quot;highlighter-rouge&quot;&gt;AppDelegate.swift&lt;/code&gt;, add the following lines just before the &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;application(_: didFinishLaunchingWithOptions:)&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window = UIWindow(frame: UIScreen.main.bounds)
let mainTabBarVC = MainTabBarVC()
window?.rootViewController = mainTabBarVC
window?.makeKeyAndVisible()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The purpose of this code is to make an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;MainTabBarVC&lt;/code&gt; the root of the app‚Äôs UI. This code serves the same purpose, conceptually speaking, as the checkbox ‚ÄúIs Initial View Controller‚Äù in storyboards.&lt;/p&gt;

&lt;p&gt;5. Note the compilation error &lt;code class=&quot;highlighter-rouge&quot;&gt;Use of unresolved identifier 'MainTabBarVC'&lt;/code&gt;. This error occurs because in the IB-based app, the storyboard specified a non-subclassed instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarController&lt;/code&gt; as the root of the app‚Äôs UI, but the PL-based app will use a named subclass, &lt;code class=&quot;highlighter-rouge&quot;&gt;MainTabBarController&lt;/code&gt;, of &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarController&lt;/code&gt;, and you need to create that subclass. Why a named subclass? The named subclass will have business logic about what tabs to create, what to name them, and what icons to use for them.&lt;/p&gt;

&lt;p&gt;Before you do that, enjoy this aside about roots and navigation. The root of an app‚Äôs UI depends on how navigation works in that app. A single-screen app would have a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; subclass as its root. A single-screen app that uses a &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt; would have have a &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt; as its root. This object would own the app‚Äôs primary &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;. An app whose navigation is based on a third-party hamburger menu like &lt;a href=&quot;https://github.com/jonkykong/SideMenu&quot;&gt;SideMenu&lt;/a&gt; would have, as its root, a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; subclass that sets up the hamburger menu.&lt;/p&gt;

&lt;p&gt;Back to the custom &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarController&lt;/code&gt; subclass. In the group &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewControllers&lt;/code&gt;, create an empty file called &lt;code class=&quot;highlighter-rouge&quot;&gt;MainTabBarVC.swift&lt;/code&gt;. Paste the following code into it:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

class MainTabBarVC: UITabBarController {
  // 0
  internal static let tabs = [&quot;Browse&quot;, &quot;Credits&quot;]

  init() {
    super.init(nibName: nil, bundle: nil)
    // 1
    let breedBrowseNavC = UINavigationController(rootViewController: BreedBrowseVC())
    // 2
    breedBrowseNavC.tabBarItem = UITabBarItem(title: MainTabBarVC.tabs[0], image: UIImage(named: MainTabBarVC.tabs[0]), selectedImage: nil)
    // 3
    let creditsVC = CreditsVC()
    // 4
    creditsVC.tabBarItem = UITabBarItem(title: MainTabBarVC.tabs[1], image: UIImage(named: MainTabBarVC.tabs[1]), selectedImage: nil)
    //5
    viewControllers = [breedBrowseNavC, creditsVC]
  }

  // 6
  required init?(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here are some explanations of this file:&lt;/p&gt;

&lt;p&gt;// 0: This line is the model of the tab bar. This model could be fancier, perhaps a separate struct or class, but an array of tab names works fine in this app.&lt;/p&gt;

&lt;p&gt;// 1: This line creates the left-hand &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;, and embeds it in a &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;, which is necessary because the user will drill down from this screen to a &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; for information about a specific cat breed. If you needed to customize &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;‚Äôs behavior, you could use a subclass of that class.&lt;/p&gt;

&lt;p&gt;// 2: This line sets the name, ‚ÄúBrowse‚Äù, and the icon, a sitting cat, of the &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarItem&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;// 3: This line creates the right-hand &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;, a &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC&lt;/code&gt;. There is no drill-down from credits, so there is no &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;// 4: This line sets the name, ‚ÄúCredits‚Äù, and the icon, a jumping cat, of the &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarItem&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;// 5: This line tells the &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBarController&lt;/code&gt; to manage the browse-and-credits &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;// 6: Swift‚Äôs initializer rules require inclusion of this initializer, but because you won‚Äôt be using a storyboard, the implementation need not be functional. More details &lt;a href=&quot;https://stackoverflow.com/a/24036440&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;6. Feel free to build, but &lt;em&gt;don‚Äôt&lt;/em&gt; run. If you do, you will see a crash caused by the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;UITableView&lt;/code&gt; expects to be instantiated from a storyboard, which isn‚Äôt happening. &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;UITextView&lt;/code&gt; has the same problem. For an initial fix, comment out the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC.swift&lt;/code&gt; and insert the following definition:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedBrowseVC: UIViewController {
  // 0
  var breedBrowseView: BreedBrowseView {
    return view as! BreedBrowseView
  }

  // 1
  override func loadView() {
    view = BreedBrowseView(frame: UIScreen.main.bounds)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(Why comment out the previous definition and not replace it? As you are converting a real app, keeping the previous definition around as a reference is helpful as you implement the new definition.)&lt;/p&gt;

&lt;p&gt;When you use storyboards, the views of your &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;s often need not be custom &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclasses. Instead, you just set properties of the view in IB. But when you use the PL approach, making every &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; property an instance of a custom &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclass is helpful because those &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s need code to set up controls and Auto Layout constraints.&lt;/p&gt;

&lt;p&gt;Here are some explanations of this definition:&lt;/p&gt;

&lt;p&gt;// 0: As mentioned earlier, with the PL approach, &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;s own instances of named &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclasses as their &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; property. Giving this property an appropriately typed alias, in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;breedBrowseView&lt;/code&gt;, allows clean access to this named-subclass instance throughout the &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;. If you only referred to the instance by its &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; name/property, you would need to cast it to a &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt; every time you referred to &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt;-specific properties and methods.&lt;/p&gt;

&lt;p&gt;The use of force-unwrap here is controversial in some quarters but carefully considered by the Author.&lt;/p&gt;

&lt;p&gt;// 1: &lt;code class=&quot;highlighter-rouge&quot;&gt;loadView()&lt;/code&gt; is a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;-lifecycle method. This is a method you may not have seen if you have been doing IB-based development. Why not? If you‚Äôve been using IB, the runtime, not your code, has been responding to calls of this method. As the &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiviewcontroller/1621454-loadview&quot;&gt;documentation&lt;/a&gt; states,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The view controller calls this method when its view property is requested but is currently nil. This method loads or creates a view and assigns it to the view property.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This implementation creates an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt; and assigns it to the &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;7. As mentioned earlier, using the PL approach, &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs &lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt; is an instance of a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclass. This subclass needs a definition, so in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Views&lt;/code&gt; group, create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView.swift&lt;/code&gt; and give it the following contents:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

class BreedBrowseView: UIView {
  required init(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  override init(frame: CGRect) {
    super.init(frame: frame)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This tutorial will fill out this definition in a later Step.&lt;/p&gt;

&lt;p&gt;8. Continuing the fix for the runtime crash, comment out the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC.swift&lt;/code&gt; and insert the following definition:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CreditsVC: UIViewController {
  var creditsView: CreditsView {
    return view as! CreditsView
  }

  override func loadView() {
    view = CreditsView(frame: UIScreen.main.bounds)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The explanation of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs definition applies to this definition as well.&lt;/p&gt;

&lt;p&gt;9. In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Views&lt;/code&gt; group, create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsView.swift&lt;/code&gt; and give it the following contents:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

class CreditsView: UIView {
  required init(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  override init(frame: CGRect) {
    super.init(frame: frame)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This tutorial will fill out this definition in a later Step.&lt;/p&gt;

&lt;p&gt;Build and run. You now have a functional PL-based app!&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/functionalApp.png&quot; title=&quot;Functional App&quot; alt=&quot;Functional App&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;A Functional PL-Based App &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;10. The next step is complete in the starter project, but, in general, the next step in the conversion of any app from IB to PL is to inventory the colors currently being used in the storyboard and put them in a data structure that your UI code can use. In a production app, these colors, and their names, might be specified in a style guide from a designer. As noted earlier, the colors in this app are from Coolors. Take a look at &lt;code class=&quot;highlighter-rouge&quot;&gt;Colors.swift&lt;/code&gt;, which contains the five Coolors colors.&lt;/p&gt;

&lt;p&gt;With respect to naming the colors, here are two possible approaches. You can choose names that reflect the actual colors, as in this app. But you might also choose more-abstract names like &lt;code class=&quot;highlighter-rouge&quot;&gt;button&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;alert&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt;. More-abstract names have the advantage that they are not tied to particular RGB values and therefore remain useful if those RGB values change radically. The disadvantage is that, for example, if you want to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt; color for something that is not text body, you will need to make an alias of that color.&lt;/p&gt;

&lt;p&gt;11. You may have noticed that the &lt;code class=&quot;highlighter-rouge&quot;&gt;Browse&lt;/code&gt; tab lacks the original table of cat breeds. The fix for this is to implement the view that holds this table. In &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView.swift&lt;/code&gt;, replace the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedBrowseView: UIView {
  // 0
  internal let table: UITableView = {
    let table = UITableView()
    // 1
    table.backgroundColor = Colors.blackish
    // 2
    table.translatesAutoresizingMaskIntoConstraints = false
    return table
  } ()

  required init(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  // 3
  override init(frame: CGRect) {
    super.init(frame: frame)
    backgroundColor = Colors.blackish
    // 4
    addSubview(table)
    // 5
    table.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor).isActive = true
    table.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor).isActive = true
    table.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor).isActive = true
    table.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor).isActive = true
  }

  // 6
  func setupTable(dataSource: UITableViewDataSource, delegate: UITableViewDelegate) {
    table.dataSource = dataSource
    table.delegate = delegate
    table.register(BreedCell.self, forCellReuseIdentifier: &quot;\(BreedCell.self)&quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here are some explanations of this new code:&lt;/p&gt;

&lt;p&gt;// 0: Using the PL approach, controls within &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s are properties of those &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s. This particular &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclass has one control, a &lt;code class=&quot;highlighter-rouge&quot;&gt;UITableView&lt;/code&gt;, and that gets defined and created here.&lt;/p&gt;

&lt;p&gt;When defining controls like &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;, the question of access level arises. &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; works if no other class needs access to the control. &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt; is appropriate in cases like this where another class, &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;, needs access to the control. Later Steps show examples of &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; controls.&lt;/p&gt;

&lt;p&gt;// 1: This line shows the &lt;a href=&quot;http://deviq.com/don-t-repeat-yourself/&quot;&gt;DRY&lt;/a&gt; power of PL. If your designer decides to give &lt;code class=&quot;highlighter-rouge&quot;&gt;blackish&lt;/code&gt; a slightly different RGB value, just change the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;blackish&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;Colors.swift&lt;/code&gt;, and all controls using that color get the new RGB values. Using the IB approach, you would need to change that color &lt;em&gt;every&lt;/em&gt; place it appears in the storyboard.&lt;/p&gt;

&lt;p&gt;The preceding sentence was not entirely accurate. As of Xcode 9 and iOS 11, &lt;a href=&quot;https://medium.com/bobo-shone/how-to-use-named-color-in-xcode-9-d7149d270a16&quot;&gt;named colors&lt;/a&gt; are available, so storyboard colors need only be set once. There are no named fonts or named paddings, however, so fonts and paddings in IB still violate DRY. Examples of DRY fonts and paddings appear later in this tutorial.&lt;/p&gt;

&lt;p&gt;// 2: When you‚Äôre using PL, you must set &lt;code class=&quot;highlighter-rouge&quot;&gt;translatesAutoresizingMaskIntoConstraints&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; for every control. If you don‚Äôt, your view &lt;a href=&quot;https://www.innoq.com/en/blog/ios-auto-layout-problem/&quot;&gt;won‚Äôt appear&lt;/a&gt;. More explanation can be found &lt;a href=&quot;https://stackoverflow.com/a/47801753&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;// 3: In the PL approach, the &lt;code class=&quot;highlighter-rouge&quot;&gt;init()&lt;/code&gt; function of a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclass has two jobs: add controls it owns as subviews of itself and constrain these controls using Auto Layout or some other approach. More details below.&lt;/p&gt;

&lt;p&gt;// 4: This line is self-explanatory but critical.&lt;/p&gt;

&lt;p&gt;// 5: This section of &lt;code class=&quot;highlighter-rouge&quot;&gt;init()&lt;/code&gt; constrains the &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;‚Äôs controls, in this case just &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;. There are many approaches to coding Auto Layout constraints. This app uses &lt;a href=&quot;https://developer.apple.com/documentation/uikit/nslayoutanchor&quot;&gt;NSLayoutAnchor&lt;/a&gt;. Sticking with first-party solutions, you could also use &lt;a href=&quot;https://developer.apple.com/documentation/uikit/nslayoutconstraint&quot;&gt;NSLayoutConstraint&lt;/a&gt; or &lt;a href=&quot;https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html&quot;&gt;Visual Format Language&lt;/a&gt; (VFL). The Author avoids &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutConstraint&lt;/code&gt; because the API is verbose and error-prone. He avoid VFL because its use of &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;s is error-prone and does not leverage type-checking to catch programmer errors.&lt;/p&gt;

&lt;p&gt;Paul Hudson has &lt;a href=&quot;https://www.hackingwithswift.com/articles/9/best-alternatives-to-auto-layout&quot;&gt;written up&lt;/a&gt; five third-party Auto Layout alternatives. The Author confirms, based on experience, that one of them, &lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot;&gt;SnapKit&lt;/a&gt;, is highly functional and intuitive. He does not use it currently, however, for four reasons:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutAnchor&lt;/code&gt; works for his needs.&lt;/li&gt;
  &lt;li&gt;He finds &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutAnchor&lt;/code&gt;‚Äôs API pleasant with an addition discussed in Step 12.&lt;/li&gt;
  &lt;li&gt;He prefers to avoid third-party dependencies when possible.&lt;/li&gt;
  &lt;li&gt;When problems occur in development with wrapped APIs, including the Auto Layout APIs, wrappers make errors more difficult to diagnose and fix.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A full-blown explanation of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutAnchor&lt;/code&gt; is beyond the scope of tutorial, but an overview discussion follows.&lt;/p&gt;

&lt;p&gt;All &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s, including the containing view, have top, bottom, leading, trailing, and center anchors. The approach is to pin anchors of &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s to the anchors of other &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s, optionally with constant space between anchors.&lt;/p&gt;

&lt;p&gt;The containing &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;‚Äôs anchors, for example &lt;code class=&quot;highlighter-rouge&quot;&gt;.leadingAnchor&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;.centerYAnchor&lt;/code&gt;, can be accessed directly. The content &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;s of &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;s have two additional properties, &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiview/1622651-layoutmarginsguide&quot;&gt;layoutMarginsGuide&lt;/a&gt; and &lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiview/2891102-safearealayoutguide&quot;&gt;safeAreaLayoutGuide&lt;/a&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;layoutMarginsGuide&lt;/code&gt; is a ‚Äúlayout guide representing the view‚Äôs margins‚Äù. Because content can be inside the margins but hidden behind a &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBar&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationBar&lt;/code&gt;, this property does not entirely encompass the concept of the space where user-visible controls should go. Pinning the top- and bottom-most controls to the &lt;code class=&quot;highlighter-rouge&quot;&gt;safeAreaLayoutGuide&lt;/code&gt;, which does not include the hidden area, prevents controls from being hidden by &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationBar&lt;/code&gt;s or &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBar&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;In the code you pasted, the goal is for the content, the cat table, to extend to the left and right margins, so the code uses &lt;code class=&quot;highlighter-rouge&quot;&gt;layoutMarginsGuide.leadingAnchor&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;layoutMarginsGuide.trailingAnchor&lt;/code&gt;. The cat table should &lt;em&gt;not&lt;/em&gt; be hidden behind a &lt;code class=&quot;highlighter-rouge&quot;&gt;UINavigationBar&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;UITabBar&lt;/code&gt;, however, so the code pins the top and bottom of the cat table to &lt;code class=&quot;highlighter-rouge&quot;&gt;safeAreaLayoutGuide.topAnchor&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;safeAreaLayoutGuide.bottomAnchor&lt;/code&gt;, respectively.&lt;/p&gt;

&lt;p&gt;// 6: This code could go in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;, but bundling it here is tidier.&lt;/p&gt;

&lt;p&gt;12. The Auto Layout code in the preceding Step is annoying for two reasons. First, &lt;code class=&quot;highlighter-rouge&quot;&gt;translatesAutoresizingMaskIntoConstraints = false&lt;/code&gt;, though necessary, is head-scratchy and hard-to-remember. Second, the syntax &lt;code class=&quot;highlighter-rouge&quot;&gt;.isActive = true&lt;/code&gt; is awkward. Doug Suriano helpfully &lt;a href=&quot;https://youtu.be/DmpoiN-SVds&quot;&gt;provides&lt;/a&gt; fixes for both in the forms of extensions on &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutConstraint&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Misc&lt;/code&gt; group, create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewExtension.swift&lt;/code&gt; and give it the following contents:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

extension UIView {
  func enableAutoLayout() {
    translatesAutoresizingMaskIntoConstraints = false
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Misc&lt;/code&gt; group, create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutConstraintExtension.swift&lt;/code&gt; and give it the following contents:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

extension NSLayoutConstraint {
  @discardableResult func activate() -&amp;gt; NSLayoutConstraint {
    isActive = true
    return self
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These two extensions provide cleaner ways to enable Auto Layout and activate constraints. How, you ask? In &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView.swift&lt;/code&gt;, replace the line&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;table.translatesAutoresizingMaskIntoConstraints = false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;table.enableAutoLayout()

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Replace the overridden &lt;code class=&quot;highlighter-rouge&quot;&gt;init()&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override init(frame: CGRect) {
  super.init(frame: frame)
  backgroundColor = Colors.blackish
  addSubview(table)
  table.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor).activate()
  table.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor).activate()
  table.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor).activate()
  table.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor).activate()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cleaner, no?&lt;/p&gt;

&lt;p&gt;Build and run. You now have a &lt;code class=&quot;highlighter-rouge&quot;&gt;UITableView&lt;/code&gt; built with PL!&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/emptyTable.png&quot; title=&quot;Empty Table&quot; alt=&quot;Empty Table&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;Empty Table Built with Programmatic Layout &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;13. You may have noticed that the cat table is sadly devoid of cats. To fix this, enhancements to &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell&lt;/code&gt; are required.&lt;/p&gt;

&lt;p&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC.swift&lt;/code&gt;. To restore the screen‚Äôs title, add the following line to the end of &lt;code class=&quot;highlighter-rouge&quot;&gt;loadView()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;title = &quot;Browse&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Like most &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;s, &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt; needs a model, so add the following line to the top of the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private let breeds = Breeds()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The cat table needs data, so change the first line of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs definition to the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedBrowseVC: UIViewController, UITableViewDelegate, UITableViewDataSource {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As an aside, the Author recognizes, past practice &lt;a href=&quot;https://github.com/vermont42/RaceRunner/blob/master/RaceRunner/RunDetailsVC.swift&quot;&gt;notwithstanding&lt;/a&gt;, that, in production apps, the implementation by &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;s of many &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt; protocols may cause code &lt;a href=&quot;http://khanlou.com/2014/09/8-patterns-to-help-you-destroy-massive-view-controller/&quot;&gt;bloat&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To fix the compilation errors, add to &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;‚Äôs definition the following implementations of the protocols:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
  return breeds.breedCount
}

func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
  let cell = breedBrowseView.table.dequeueReusableCell(withIdentifier: &quot;\(BreedCell.self)&quot;) as! BreedCell
  let breed = breeds.breedAtIndex(indexPath.row)
  cell.configure(name: breed.name, photo: breed.photo)
  return cell
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is an example of why, when converting an app from IB to PL, the developer should initially comment out, not delete, code. The code above is identical to the IB-based code except for the fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt; is now owned by &lt;code class=&quot;highlighter-rouge&quot;&gt;breedBrowseView&lt;/code&gt;, not &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;14. In order to populate the cat table, add the following line to the end of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC.loadView()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;breedBrowseView.setupTable(dataSource: self, delegate: self)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;15. Feel free to build, but &lt;em&gt;don‚Äôt&lt;/em&gt; run. If you do, a &lt;a href=&quot;https://fatalerror.fm/&quot;&gt;fatal error&lt;/a&gt; will occur in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell.swift&lt;/code&gt; because there are outlets between &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell&lt;/code&gt; and the unused storyboard. Fatal error aside, there are no Auto Layout constraints on this view. Replace the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedCell: UITableViewCell {
  private var photo: UIImageView = {
    let photo = UIImageView()
    photo.contentMode = .scaleAspectFit
    photo.enableAutoLayout()
    return photo
  } ()

  private var name: UILabel = {
    let name = UILabel()
    name.textColor = Colors.white
    // 0
    name.font = Fonts.body
    name.enableAutoLayout()
    return name
  } ()

  // 1
  internal static let thumbnailHeightWidth: CGFloat = 58.0

  required init?(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  override init(style: UITableViewCellStyle, reuseIdentifier: String?) {
    super.init(style: style, reuseIdentifier: reuseIdentifier)
    backgroundColor = Colors.blackish
    addSubview(photo)
    addSubview(name)
    // 2
    photo.centerYAnchor.constraint(equalTo: centerYAnchor).activate()
    photo.leadingAnchor.constraint(equalTo: leadingAnchor).activate()
    photo.heightAnchor.constraint(equalToConstant: BreedCell.thumbnailHeightWidth).activate()
    photo.widthAnchor.constraint(equalToConstant: BreedCell.thumbnailHeightWidth).activate()
    name.leadingAnchor.constraint(equalTo: photo.trailingAnchor, constant: 8.0).activate()
    name.centerYAnchor.constraint(equalTo: centerYAnchor).activate()
  }

  internal func configure(name: String, photo: UIImage) {
    self.name.text = name
    self.photo.image = photo
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The structure of this code should be familiar from &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt;, but here are some comments:&lt;/p&gt;

&lt;p&gt;// 0: One step in the conversion of an app from IB to to PL is to inventory the fonts used in the app and centralize them in one file. As with colors, in a production app, these fonts, and their names, might be specified in a style guide from a designer. The Author has identified the fonts for you. They are in the file &lt;code class=&quot;highlighter-rouge&quot;&gt;Fonts.swift&lt;/code&gt;, and he uses one of them for &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell.name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;// 1: In the IB version of this app, the height of the cat thumbnail, the width of that thumbnail, and the height of each row were identical but repeated twice, violating DRY. Defining this value once here promotes DRY.&lt;/p&gt;

&lt;p&gt;// 2: This Auto Layout code demonstrates three new types of anchors: &lt;code class=&quot;highlighter-rouge&quot;&gt;heightAnchor&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;widthAnchor&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;centerYAnchor&lt;/code&gt;. The Author hopes you find these usages &lt;a href=&quot;https://blogging.com/ten-dollar-copy-words/&quot;&gt;pellucid&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;16. The table‚Äôs rows currently have a default height, not the appropriate height based on the height of the cat thumbnails. To fix this, add the following implementation to the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC.swift&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&amp;gt; CGFloat {
  return BreedCell.thumbnailHeightWidth
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Build &lt;em&gt;and&lt;/em&gt; run. You now have a cat table made with PL!&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/catTable.png&quot; title=&quot;Cat Table&quot; alt=&quot;Cat Table&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;Cat Table Built with Programmatic Layout &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;17: &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell.init()&lt;/code&gt; has a magic number: &lt;code class=&quot;highlighter-rouge&quot;&gt;8.0&lt;/code&gt;. This is the amount of space or ‚Äúpadding‚Äù between the thumbnail and the &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; label. For a variety of reasons ably summarized &lt;a href=&quot;https://stackoverflow.com/a/47890&quot;&gt;here&lt;/a&gt;, magic numbers are bad. The next step in the conversion of this (or any) app from IB to PL is to identify paddings used in the storyboard and isolate them in one place. As with colors, in a production app, these paddings, and their names, might be specified in a style guide from a designer. The Author has identified these paddings for you. In the group &lt;code class=&quot;highlighter-rouge&quot;&gt;Models&lt;/code&gt;, create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;Padding.swift&lt;/code&gt; and give it the following contents:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

struct Padding {
  static let standard: CGFloat = 8.0
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell.swift&lt;/code&gt;, change the &lt;code class=&quot;highlighter-rouge&quot;&gt;8.0&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedCell.init()&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;Padding.standard&lt;/code&gt;. Buh-bye, magic number.&lt;/p&gt;

&lt;p&gt;18. The IB-based version of the app allowed the user to tap a row in the cat table and see a large photo and description of that breed. Time to implement that.&lt;/p&gt;

&lt;p&gt;The IB-based app did not use a named &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; subclass for displaying breed details, but the PL-based app &lt;em&gt;must&lt;/em&gt; have one. In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Views&lt;/code&gt; group, create a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailView&lt;/code&gt; with the following contents:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import UIKit

class BreedDetailView: UIView {
  required init(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  override init(frame: CGRect) {
    super.init(frame: frame)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;19. &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; currently assumes that that it‚Äôs being instantiated from a storyboard, so in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC.swift&lt;/code&gt;, replace the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedDetailVC: UIViewController, UITextViewDelegate {
  private var breed: Breed!

  var breedDetailView: BreedDetailView {
    return view as! BreedDetailView
  }

  override func loadView() {
    view = BreedDetailView(frame: UIScreen.main.bounds)
    title = breed.name
  }

  // 0
  class func getViewController(breed: Breed) -&amp;gt; BreedDetailVC {
    let breedDetailVC = BreedDetailVC()
    breedDetailVC.breed = breed
    return breedDetailVC
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code is similar to that of other &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; subclasses discussed, with the following exception:&lt;/p&gt;

&lt;p&gt;// 0: This function is a clean way for clients to instantiate a &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; with precisely the model data it needs, an instance of &lt;code class=&quot;highlighter-rouge&quot;&gt;Breed&lt;/code&gt;. Clients could initialize &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; directly, but if they did, they would have to remember to set the &lt;code class=&quot;highlighter-rouge&quot;&gt;breed&lt;/code&gt; property, which would need to be &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;. In this situation, instances of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; would be in an unusable state until clients set the value of the &lt;code class=&quot;highlighter-rouge&quot;&gt;breed&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;The benefit of the approach used here becomes even more apparent when &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; subclasses have many properties that need to be set. Because of Xcode‚Äôs autocompletion of &lt;code class=&quot;highlighter-rouge&quot;&gt;getViewController()&lt;/code&gt;‚Äôs arguments, clients never forget to provide necessary value(s).&lt;/p&gt;

&lt;p&gt;20. To allow the transition from &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedViewVC&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt;, in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC.swift&lt;/code&gt;, add the following to the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  tableView.deselectRow(at: indexPath, animated: false)
  let breedDetailVC = BreedDetailVC.getViewController(breed: breeds.breedAtIndex(indexPath.row))
  navigationController?.pushViewController(breedDetailVC, animated: true)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Build and run. Click a row in the cat table. The app transitions to an empty screen about that breed.&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/emptyBreed.png&quot; title=&quot;Empty Breed Screen&quot; alt=&quot;Empty Breed Screen&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;An Empty Breed Screen &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;21. You may notice that the transition to &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; is choppy. The Author is unsure why this happens, but he saw the same thing when &lt;a href=&quot;https://github.com/vermont42/Conjugar&quot;&gt;developing&lt;/a&gt; &lt;a href=&quot;https://itunes.apple.com/us/app/conjugar/id1236500467&quot;&gt;Conjugar&lt;/a&gt;. The fix is to add to the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC.swift&lt;/code&gt; the following function:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override func viewWillAppear(_ animated: Bool) {
  super.viewWillAppear(animated)
  breedBrowseView.isHidden = false
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the function &lt;code class=&quot;highlighter-rouge&quot;&gt;tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath)&lt;/code&gt;, just before the line &lt;code class=&quot;highlighter-rouge&quot;&gt;navigationController?.pushViewController(...)&lt;/code&gt;, add the following line:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;breedBrowseView.isHidden = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This fixes the choppiness. The Author is open to less-hacky suggestions.&lt;/p&gt;

&lt;p&gt;22. Time for some breed info. In &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailView.swift&lt;/code&gt;, replace the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailView&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedDetailView: UIView {
  internal var photo: UIImageView = {
    let photo = UIImageView()
    photo.contentMode = .scaleAspectFit
    photo.enableAutoLayout()
    return photo
  } ()

  internal var fullDescription: UITextView = {
    let fullDescription = UITextView()
    fullDescription.textColor = Colors.white
    fullDescription.backgroundColor = Colors.blackish
    fullDescription.font = Fonts.body
    fullDescription.bounces = false
    fullDescription.enableAutoLayout()
    return fullDescription
  } ()

  // 0
  internal static let initialPhotoHeightWidth: CGFloat = 180.0
  private var photoHeight: NSLayoutConstraint?
  private var photoWidth: NSLayoutConstraint?

  required init(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  override init(frame: CGRect) {
    super.init(frame: frame)
    backgroundColor = Colors.blackish
    addSubview(photo)
    addSubview(fullDescription)
    photo.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor).activate()
    photo.centerXAnchor.constraint(equalTo: centerXAnchor).activate()
    // 1
    photoHeight = photo.heightAnchor.constraint(equalToConstant: BreedDetailView.initialPhotoHeightWidth)
    photoHeight?.activate()
    photoWidth = photo.widthAnchor.constraint(equalToConstant: BreedDetailView.initialPhotoHeightWidth)
    photoWidth?.activate()
    fullDescription.topAnchor.constraint(equalTo: photo.bottomAnchor, constant: Padding.standard).activate()
    fullDescription.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor).activate()
    fullDescription.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor).activate()
    fullDescription.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor).activate()
  }

  // 2
  internal func updatePhotoSize(heightWidth: CGFloat) {
    photoWidth?.constant = heightWidth
    photoHeight?.constant = heightWidth
  }

  // 3
  internal func hide() {
    photo.isHidden = true
    fullDescription.isHidden = true
  }

  internal func unhide() {
    photo.isHidden = false
    fullDescription.isHidden = false
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code is similar to that of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt; with the exceptions discussed here.&lt;/p&gt;

&lt;p&gt;// 0: The &lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;width&lt;/code&gt; constraints are unusual in that they vary based on the &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; position of the &lt;code class=&quot;highlighter-rouge&quot;&gt;UITextView&lt;/code&gt;. Because these constraints vary, they are given persistent names and an initial value here. The initial value, &lt;code class=&quot;highlighter-rouge&quot;&gt;initialPhotoHeightWidth&lt;/code&gt;, is &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt; because &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; needs to access it to tell &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedView&lt;/code&gt; what value to change it to as the user scrolls.&lt;/p&gt;

&lt;p&gt;// 1: These four lines differ from the setup of most &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutAnchor&lt;/code&gt; constraints because the two constraints, photo height and width, can vary and are therefore named.&lt;/p&gt;

&lt;p&gt;// 2: This is a convenience function for &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; to call when the user scrolls. This function allows the two constraints to be &lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailView&lt;/code&gt;. If not for this function, those two constraints would need to be &lt;code class=&quot;highlighter-rouge&quot;&gt;internal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;// 3: &lt;code class=&quot;highlighter-rouge&quot;&gt;hide()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;unhide()&lt;/code&gt; are necessitated by the strange fact that &lt;code class=&quot;highlighter-rouge&quot;&gt;fullDescription&lt;/code&gt; starts at a nonzero vertical offset. &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; sets the initial vertical offset to &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, using &lt;code class=&quot;highlighter-rouge&quot;&gt;hide()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;unhide()&lt;/code&gt; to shield the user from flickering. On a meta note, this sort of hackery is another example of the challenges that the PL approach can present.&lt;/p&gt;

&lt;p&gt;23. In &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC.swift&lt;/code&gt;, replace the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; with the following.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BreedDetailVC: UIViewController, UITextViewDelegate {
  private var breed: Breed!

  var breedDetailView: BreedDetailView {
    return view as! BreedDetailView
  }

  override func loadView() {
    title = breed.name
    let breedDetailView = BreedDetailView(frame: UIScreen.main.bounds)
    breedDetailView.fullDescription.text = breed.fullDescription
    breedDetailView.fullDescription.delegate = self
    breedDetailView.photo.image = breed.photo
    view = breedDetailView
  }

  override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    breedDetailView.hide()
  }

  override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    breedDetailView.fullDescription.setContentOffset(.zero, animated: false)
    breedDetailView.unhide()
  }

  class func getViewController(breed: Breed) -&amp;gt; BreedDetailVC {
    let breedDetailVC = BreedDetailVC()
    breedDetailVC.breed = breed
    return breedDetailVC
  }

  func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let y = breedDetailView.fullDescription.contentOffset.y
    if y &amp;lt; BreedDetailView.initialPhotoHeightWidth {
      breedDetailView.updatePhotoSize(heightWidth: BreedDetailView.initialPhotoHeightWidth - y)
    } else {
      breedDetailView.updatePhotoSize(heightWidth: 0.0)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedDetailVC&lt;/code&gt; is similar to that of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseVC&lt;/code&gt;, but see Part 23, Comment 3 for a discussion of the hackery involving &lt;code class=&quot;highlighter-rouge&quot;&gt;hide()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;unhide()&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;setContentOffset()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Build &lt;em&gt;and&lt;/em&gt; run. You now have a working breed-details screen. Scroll to see the nifty photo-shrinking effect.&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/breedDetail.png&quot; title=&quot;Breed Detail&quot; alt=&quot;Breed Detail&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;Details on the Tonkinese Breed &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;24. Time to convert the credits screen. In &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsView.swift&lt;/code&gt;, replace the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsView&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CreditsView: UIView {
  internal var credits: UITextView = {
    let credits = UITextView()
    credits.textColor = Colors.white
    credits.backgroundColor = Colors.blackish
    credits.font = Fonts.body
    credits.enableAutoLayout()
    // 0
    credits.isEditable = false
    return credits
  } ()

  // 1
  internal let meow1: UIButton = {
    let meow1 = UIButton()
    meow1.setTitle(&quot;Meow 1&quot;, for: .normal)
    meow1.titleLabel?.font = Fonts.button
    meow1.setTitleColor(Colors.greenish, for: .normal)
    meow1.enableAutoLayout()
    return meow1
  } ()

  internal let meow2: UIButton = {
    let meow2 = UIButton()
    meow2.setTitle(&quot;Meow 2&quot;, for: .normal)
    meow2.titleLabel?.font = Fonts.button
    meow2.setTitleColor(Colors.greenish, for: .normal)
    meow2.enableAutoLayout()
    return meow2
  } ()

  required init(coder aDecoder: NSCoder) {
    fatalError(&quot;init(coder:) has not been implemented.&quot;)
  }

  override init(frame: CGRect) {
    super.init(frame: frame)
    backgroundColor = Colors.blackish
    // 2
    [credits, meow1, meow2].forEach {
      addSubview($0)
    }
    credits.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor, constant: Padding.standard).activate()
    // 3
    credits.bottomAnchor.constraint(equalTo: meow1.topAnchor, constant: Padding.standard * -1.0).activate()
    credits.bottomAnchor.constraint(equalTo: meow2.topAnchor, constant: Padding.standard * -1.0).activate()
    credits.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor).activate()
    credits.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor).activate()

    meow1.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor, constant: Padding.standard * -1.0).activate()
    meow1.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor).activate()

    meow2.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor, constant: Padding.standard * -1.0).activate()
    meow2.trailingAnchor.constraint(equalTo: layoutMarginsGuide.trailingAnchor).activate()
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsView&lt;/code&gt; is similar to that of &lt;code class=&quot;highlighter-rouge&quot;&gt;BreedBrowseView&lt;/code&gt;, discussed in Step 11, but here are some comments about peculiarities of this implementation.&lt;/p&gt;

&lt;p&gt;// 0: &lt;code class=&quot;highlighter-rouge&quot;&gt;UITextView&lt;/code&gt;s default to editable, which is inappropriate for this app. The user shouldn‚Äôt be able to edit the credits. Also, if the &lt;code class=&quot;highlighter-rouge&quot;&gt;UITextView&lt;/code&gt; is editable, URLs can‚Äôt be tapped to launch Safari. You‚Äôll notice that &lt;code class=&quot;highlighter-rouge&quot;&gt;Editable&lt;/code&gt; is unchecked in the storyboard, so this line replicates that. On a meta note, an important part of converting a UI from IB to PL is ensuring that non-default values in the storyboard, such as &lt;code class=&quot;highlighter-rouge&quot;&gt;editable&lt;/code&gt;, are preserved in the code.&lt;/p&gt;

&lt;p&gt;// 1: This definition and the one after it are for the two meow buttons. You might notice that there is a lot of code duplicated between the two definitions. Depending on your use case, it might make sense to factor out code that is shared among controls. Here is an example of that from &lt;a href=&quot;https://github.com/vermont42/Conjugar&quot;&gt;Conjugar&lt;/a&gt;:&lt;/p&gt;

&lt;figure&gt;
    &lt;img class=&quot;img-thumbnail img-responsive center &quot; src=&quot;/img/programmaticLayout/Conjugar.png&quot; title=&quot;Conjugar&quot; alt=&quot;Conjugar&quot; /&gt;
    
        &lt;figcaption&gt;
            &lt;p&gt;&lt;small class=&quot;text-muted center&quot;&gt;Conjugation of O√≠r in Conjugar &lt;/small&gt;&lt;/p&gt;
        &lt;/figcaption&gt;
    
&lt;/figure&gt;

&lt;p&gt;There are nine &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;s near the top of the screen that are identical except for their content. Rather than repeating the setup of each &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;, the Author &lt;a href=&quot;https://github.com/vermont42/Conjugar/blob/master/Conjugar/VerbView.swift&quot;&gt;factored out&lt;/a&gt; shared setup. This shared code could at the top of &lt;code class=&quot;highlighter-rouge&quot;&gt;init()&lt;/code&gt;, as in Conjugar, or in a separate function. Here is how Conjugar avoids duplication of code for the &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;s:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[translation, parentOrType, participioLabel, participio, gerundioLabel, gerundio, raizFuturaLabel, raizFutura, defectivo].forEach {
  $0.font = Fonts.label
  $0.textColor = Colors.yellow
  $0.enableAutoLayout()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// 2: Here is an example of using &lt;code class=&quot;highlighter-rouge&quot;&gt;forEach()&lt;/code&gt; to avoid code duplication.&lt;/p&gt;

&lt;p&gt;// 3: The &lt;code class=&quot;highlighter-rouge&quot;&gt;constant&lt;/code&gt; parameter of &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutAnchor.constraint()&lt;/code&gt; sometimes has negative semantics. That is, a positive value results in the opposite padding of what the developer expects. In this situation, the developer must multiply the padding by &lt;code class=&quot;highlighter-rouge&quot;&gt;-1.0&lt;/code&gt;, as here, to get the desired behavior.&lt;/p&gt;

&lt;p&gt;25. In order to use this new &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsView&lt;/code&gt;, replace the implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;CreditsVC.swift&lt;/code&gt; with the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class CreditsVC: UIViewController, UITextViewDelegate {
  var creditsView: CreditsView {
    return view as! CreditsView
  }

  override func loadView() {
    let creditsView = CreditsView(frame: UIScreen.main.bounds)
    creditsView.credits.attributedText = Credits.credits.infoString
    creditsView.credits.delegate = self
    // 0
    creditsView.meow1.addTarget(self, action: #selector(meow1), for: .touchUpInside)
    creditsView.meow2.addTarget(self, action: #selector(meow2), for: .touchUpInside)
    view = creditsView
  }

  // 1
  @objc func meow1(sender: UIButton!) {
    SoundManager.play(.meow1)
  }

  @objc func meow2(sender: UIButton!) {
    SoundManager.play(.meow2)
  }

  func textView(_ textView: UITextView, shouldInteractWith URL: URL, in characterRange: NSRange) -&amp;gt; Bool {
    let http = &quot;http&quot;
    if URL.absoluteString.prefix(http.count) == http {
      return true
    }
    else {
      return false
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The final implementation of this &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; subclass is similar to those of others you have seen, with a wrinkle.&lt;/p&gt;

&lt;p&gt;// 0: As you may have experienced, the way to implement a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt; tap using the IB approach is to control-drag from the &lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt; in the storyboard to the &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt; implementation. This code shows the PL approach: add targets in code to the &lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt;s and provide implementations for the selectors you specify. The approach is similar for other controls like &lt;code class=&quot;highlighter-rouge&quot;&gt;UISegmentedControl&lt;/code&gt;. Here is an example from &lt;a href=&quot;https://github.com/vermont42/Conjugar/blob/master/Conjugar/BrowseVerbsVC.swift&quot;&gt;Conjugar&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;override func loadView() {
  ...
  browseVerbsView.filterControl.addTarget(self, action: #selector(BrowseVerbsVC.valueChanged(_:)), for: .valueChanged)
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;// 1: This is an implementation of a selector that fires when the user taps a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIButton&lt;/code&gt;. The &lt;code class=&quot;highlighter-rouge&quot;&gt;@objc&lt;/code&gt; keyword is required to expose the implementation to the Objective-C runtime.&lt;/p&gt;

&lt;p&gt;On an illustrative note, here is the implementation of a selector for a &lt;code class=&quot;highlighter-rouge&quot;&gt;UISegmentedControl&lt;/code&gt; in &lt;a href=&quot;https://github.com/vermont42/Conjugar/blob/master/Conjugar/BrowseVerbsVC.swift&quot;&gt;Conjugar&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@objc func valueChanged(_ sender: UISegmentedControl) {
  browseVerbsView.reloadTableData()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;26. Conversion is complete! For the sake of &lt;a href=&quot;https://theendlessfurther.com/tag/kanso/&quot;&gt;Á∞°Á¥†&lt;/a&gt;, delete &lt;code class=&quot;highlighter-rouge&quot;&gt;Main.storyboard&lt;/code&gt; and commented-out IB-dependent code. A fully converted version of the app is available &lt;a href=&quot;&quot;&gt;here&lt;/a&gt;. Enjoy learning about cat breeds.&lt;/p&gt;

&lt;h3 id=&quot;closing-thoughts&quot;&gt;Closing Thoughts&lt;/h3&gt;

&lt;p&gt;The Author encourages you to use the learnings in this tutorial to start converting your app from IB to PL, if appropriate for your use case. He recommends that you investigate the Auto Layout options described in the Paul Hudson &lt;a href=&quot;https://www.hackingwithswift.com/articles/9/best-alternatives-to-auto-layout&quot;&gt;article&lt;/a&gt;. Although the Author does not take addition of third-party dependencies &lt;a href=&quot;https://github.com/vermont42/RaceRunner/blob/master/Podfile&quot;&gt;lightly&lt;/a&gt;,  &lt;a href=&quot;https://github.com/SnapKit/SnapKit&quot;&gt;SnapKit&lt;/a&gt; provides such a clean API that he considers that framework to be a viable alternative to raw &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutAnchor&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;credits&quot;&gt;Credits&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/matt_luedke&quot;&gt;Matt&lt;/a&gt; &lt;a href=&quot;https://soundcloud.com/good_day_sir/real-thing-instrumental&quot;&gt;Luedke&lt;/a&gt; shared PL‚Äôs benefits with the Author and taught him its use.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/dougsuriano&quot;&gt;Doug Suriano&lt;/a&gt; created extensions on &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;NSLayoutConstraint&lt;/code&gt; that improve the PL experience.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://twitter.com/IOSDEVUK&quot;&gt;iOSDevUK&lt;/a&gt;, by accepting the Author‚Äôs proposal for a talk on PL, motivated him to create &lt;a href=&quot;https://github.com/vermont42/Conjugar&quot;&gt;Conjugar&lt;/a&gt;, his first PL-from-scratch app. This tutorial is a companion piece to the talk he presented.&lt;/li&gt;
&lt;/ul&gt;

        </content>
    </entry>
    
</feed>
